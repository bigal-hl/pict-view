"use strict";!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).PictView=e()}}((function(){return function e(t,i,s){function o(r,a){if(!i[r]){if(!t[r]){var h="function"==typeof require&&require;if(!a&&h)return h(r,!0);if(n)return n(r,!0);var l=new Error("Cannot find module '"+r+"'");throw l.code="MODULE_NOT_FOUND",l}var c=i[r]={exports:{}};t[r][0].call(c.exports,(function(e){return o(t[r][1][e]||e)}),c,c.exports,e,t,i,s)}return i[r].exports}for(var n="function"==typeof require&&require,r=0;r<s.length;r++)o(s[r]);return o}({1:[function(e,t,i){t.exports={name:"fable-serviceproviderbase",version:"3.0.15",description:"Simple base classes for fable services.",main:"source/Fable-ServiceProviderBase.js",scripts:{start:"node source/Fable-ServiceProviderBase.js",test:"npx mocha -u tdd -R spec",tests:"npx mocha -u tdd --exit -R spec --grep",coverage:"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec",build:"npx quack build"},mocha:{diff:!0,extension:["js"],package:"./package.json",reporter:"spec",slow:"75",timeout:"5000",ui:"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},repository:{type:"git",url:"https://github.com/stevenvelozo/fable-serviceproviderbase.git"},keywords:["entity","behavior"],author:"Steven Velozo <steven@velozo.com> (http://velozo.com/)",license:"MIT",bugs:{url:"https://github.com/stevenvelozo/fable-serviceproviderbase/issues"},homepage:"https://github.com/stevenvelozo/fable-serviceproviderbase",devDependencies:{fable:"^3.0.143",quackage:"^1.0.33"}}},{}],2:[function(e,t,i){const s=e("../package.json");class o{constructor(e,t,i){"object"==typeof e&&e.isFable?this.connectFable(e):this.fable=!1,this._PackageFableServiceProvider=s,this.fable?(this.UUID=e.getUUID(),this.options="object"==typeof t?t:{}):(this.options="object"!=typeof e||e.isFable?"object"==typeof t?t:{}:e,this.UUID=`CORE-SVC-${Math.floor(89999*Math.random()+1e4)}`),this.serviceType=`Unknown-${this.UUID}`,this.Hash="string"==typeof i?i:this.fable||"string"!=typeof t?`${this.UUID}`:t}connectFable(e){if("object"!=typeof e||!e.isFable){let t=`Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof e}].}`;return console.log(t),new Error(t)}return this.fable||(this.fable=e),this.log||(this.log=this.fable.Logging),this.services||(this.services=this.fable.services),this.servicesMap||(this.servicesMap=this.fable.servicesMap),!0}static isFableService=!0}t.exports=o,t.exports.CoreServiceProviderBase=o},{"../package.json":1}],3:[function(e,t,i){t.exports={name:"pict-view",version:"1.0.54",description:"Pict View Base Class",main:"source/Pict-View.js",scripts:{test:"./node_modules/.bin/mocha -u tdd -R spec",start:"node source/Pict-View.js",coverage:"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec",build:"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-view-image:local","docker-dev-run":'docker run -it -d --name pict-view-dev -p 30001:8080 -p 38086:8086 -v "$PWD/.config:/home/coder/.config"  -v "$PWD:/home/coder/pict-view" -u "$(id -u):$(id -g)" -e "DOCKER_USER=$USER" pict-view-image:local',"docker-dev-shell":"docker exec -it pict-view-dev /bin/bash",types:"npx -p typescript tsc -p . --outDir types"},types:"types/Pict-View.d.ts",repository:{type:"git",url:"git+https://github.com/stevenvelozo/pict-view.git"},author:"steven velozo <steven@velozo.com>",license:"MIT",bugs:{url:"https://github.com/stevenvelozo/pict-view/issues"},homepage:"https://github.com/stevenvelozo/pict-view#readme",devDependencies:{"browser-env":"^3.3.0",pict:"^1.0.215",quackage:"^1.0.33",typescript:"^5.6.2"},mocha:{diff:!0,extension:["js"],package:"./package.json",reporter:"spec",slow:"75",timeout:"5000",ui:"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},dependencies:{fable:"^3.0.145","fable-serviceproviderbase":"^3.0.15"}}},{}],4:[function(e,t,i){const s=e("fable-serviceproviderbase"),o=e("../package.json"),n={DefaultRenderable:!1,DefaultDestinationAddress:!1,DefaultTemplateRecordAddress:!1,ViewIdentifier:!1,AutoInitialize:!0,AutoInitializeOrdinal:0,AutoRender:!0,AutoRenderOrdinal:0,AutoSolveWithApp:!0,AutoSolveOrdinal:0,CSSHash:!1,CSS:!1,CSSProvider:!1,CSSPriority:500,Templates:[],DefaultTemplates:[],Renderables:[],Manifests:{}};t.exports=class extends s{constructor(e,t,i){super(e,Object.assign({},JSON.parse(JSON.stringify(n)),t),i),this.fable,this.options,this.UUID,this.Hash,this.log,this.options.ViewIdentifier||(this.options.ViewIdentifier=`AutoViewID-${this.fable.getUUID()}`),this.serviceType="PictView",this._Package=o,this.pict=this.fable,this.AppData=this.pict.AppData,this.initializeTimestamp=!1,this.lastSolvedTimestamp=!1,this.lastRenderedTimestamp=!1,this.lastMarshalFromViewTimestamp=!1,this.lastMarshalToViewTimestamp=!1;for(let e=0;e<this.options.Templates.length;e++){let t=this.options.Templates[e];"Hash"in t&&"Template"in t?(t.Source||(t.Source=`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`),this.pict.TemplateProvider.addTemplate(t.Hash,t.Template,t.Source)):this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${e} in the options array.`,t)}for(let e=0;e<this.options.DefaultTemplates.length;e++){let t=this.options.DefaultTemplates[e];"Postfix"in t&&"Template"in t?(t.Source||(t.Source=`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`),this.pict.TemplateProvider.addDefaultTemplate(t.Prefix,t.Postfix,t.Template,t.Source)):this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${e} in the options array.`,t)}if(this.options.CSS){let e=this.options.CSSHash?this.options.CSSHash:`View-${this.options.ViewIdentifier}`,t=this.options.CSSProvider?this.options.CSSProvider:e;this.pict.CSSMap.addCSS(e,this.options.CSS,t,this.options.CSSPriority)}this.renderables={};for(let e=0;e<this.options.Renderables.length;e++){let t=this.options.Renderables[e];this.addRenderable(t)}}addRenderable(e,t,i,s,o){let n;if("object"==typeof e)n=e;else{n={RenderableHash:e,TemplateHash:t,DefaultTemplateRecordAddress:i,ContentDestinationAddress:s,RenderMethod:"string"!=typeof o?o:"replace"}}"string"!=typeof n.RenderableHash||"string"!=typeof n.TemplateHash?this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`,n):(this.pict.LogNoisiness>0&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${n.RenderableHash}] pointed to template ${n.TemplateHash}.`),this.renderables[n.RenderableHash]=n)}onBeforeInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`),!0}onBeforeInitializeAsync(e){return this.onBeforeInitialize(),e()}onInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`),!0}onInitializeAsync(e){return this.onInitialize(),e()}initialize(){return this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`),this.initializeTimestamp?(this.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`),!1):(this.onBeforeInitialize(),this.onInitialize(),this.onAfterInitialize(),this.initializeTimestamp=this.pict.log.getTimeStamp(),!0)}initializeAsync(e){if(this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`),this.initializeTimestamp)return this.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`),e();{let t=this.pict.instantiateServiceProviderWithoutRegistration("Anticipate");this.pict.LogNoisiness>0&&this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`),t.anticipate(this.onBeforeInitializeAsync.bind(this)),t.anticipate(this.onInitializeAsync.bind(this)),t.anticipate(this.onAfterInitializeAsync.bind(this)),t.wait((t=>(this.initializeTimestamp=this.pict.log.getTimeStamp(),this.pict.LogNoisiness>0&&this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`),e())))}}onAfterInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`),!0}onAfterInitializeAsync(e){return this.onAfterInitialize(),e()}onBeforeRender(e,t,i){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`),!0}onBeforeRenderAsync(e){return e()}buildRenderOptions(e,t,i){let s={Valid:!0};return s.RenderableHash="string"==typeof e?e:"string"==typeof this.options.DefaultRenderable&&this.options.DefaultRenderable,s.RenderableHash||(this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${s.RenderableHash} (param ${e}because it is not a valid renderable.`),s.Valid=!1),s.Renderable=this.renderables[s.RenderableHash],s.Renderable||(this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${s.RenderableHash} (param ${e}) because it does not exist.`),s.Valid=!1),s.DestinationAddress="string"==typeof t?t:"string"==typeof s.Renderable.ContentDestinationAddress?s.Renderable.ContentDestinationAddress:"string"==typeof this.options.DefaultDestinationAddress&&this.options.DefaultDestinationAddress,s.DestinationAddress||(this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${s.RenderableHash} (param ${e}) because it does not have a valid destination address (param ${t}).`),s.Valid=!1),"object"==typeof i?(s.RecordAddress="Passed in as object",s.Record=i):(s.RecordAddress="string"==typeof i?i:"string"==typeof s.Renderable.DefaultTemplateRecordAddress?s.Renderable.DefaultTemplateRecordAddress:"string"==typeof this.options.DefaultTemplateRecordAddress&&this.options.DefaultTemplateRecordAddress,s.Record="string"==typeof tmpRecordAddress?this.pict.DataProvider.getDataByAddress(tmpRecordAddress):void 0),s}assignRenderContent(e,t,i){switch(e.RenderMethod){case"append":return this.pict.ContentAssignment.appendContent(t,i);case"prepend":return this.pict.ContentAssignment.prependContent(t,i);case"append_once":if(this.pict.ContentAssignment.getElement(`#${e.DestinationAddress}`).length<1)return this.pict.ContentAssignment.appendContent(t,i);break;default:return this.pict.ContentAssignment.assignContent(t,i)}return!1}render(e,t,i){let s="string"==typeof e?e:"string"==typeof this.options.DefaultRenderable&&this.options.DefaultRenderable;if(!s)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${s} (param ${e}) because it is not a valid renderable.`),!1;let o=this.renderables[s];if(!o)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${s} (param ${e}) because it does not exist.`),!1;let n,r,a="string"==typeof t?t:"string"==typeof o.ContentDestinationAddress?o.ContentDestinationAddress:"string"==typeof this.options.DefaultDestinationAddress&&this.options.DefaultDestinationAddress;if(!a)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${s} (param ${e}) because it does not have a valid destination address.`),!1;"object"==typeof i?(r=i,n="Passed in as object"):(n="string"==typeof i?i:"string"==typeof o.DefaultTemplateRecordAddress?o.DefaultTemplateRecordAddress:"string"==typeof this.options.DefaultTemplateRecordAddress&&this.options.DefaultTemplateRecordAddress,r="string"==typeof n?this.pict.DataProvider.getDataByAddress(n):void 0),this.onBeforeRender(o,a,r),this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${s}] Destination[${a}] TemplateRecordAddress[${n}] render:`),this.pict.LogNoisiness>0&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${s}] to Destination [${a}]...`);let h=this.pict.parseTemplateByHash(o.TemplateHash,r,null,[this]);switch(this.pict.LogNoisiness>0&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${s}] content length ${h.length} to Destination [${a}] using render method [${o.RenderMethod}].`),o.RenderMethod){case"append":this.pict.ContentAssignment.appendContent(a,h);break;case"prepend":this.pict.ContentAssignment.prependContent(a,h);break;case"append_once":this.pict.ContentAssignment.getElement(`${o.DestinationAddress}`).length<1&&this.pict.ContentAssignment.appendContent(a,h);break;default:this.pict.ContentAssignment.assignContent(a,h)}return this.onAfterRender(o,a,r,h),this.lastRenderedTimestamp=this.pict.log.getTimeStamp(),!0}renderAsync(e,t,i,s){let o="string"==typeof e?e:"string"==typeof this.options.DefaultRenderable&&this.options.DefaultRenderable,n="function"==typeof s?s:"function"==typeof i?i:"function"==typeof t?t:"function"==typeof e&&e;if(n||(this.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),n=e=>{e&&this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${e}`,e)}),!o)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${o} (param ${e}because it is not a valid renderable.`),n(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${o} (param ${e}because it is not a valid renderable.`));let r=this.renderables[o];if(!r)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${o} (param ${e}) because it does not exist.`),n(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${o} (param ${e}) because it does not exist.`));let a,h,l="string"==typeof t?t:"string"==typeof r.ContentDestinationAddress?r.ContentDestinationAddress:"string"==typeof this.options.DefaultDestinationAddress&&this.options.DefaultDestinationAddress;if(!l)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${o} (param ${e}) because it does not have a valid destination address.`),n(Error(`Could not render ${o}`));"object"==typeof i?(h=i,a="Passed in as object"):(a="string"==typeof i?i:"string"==typeof r.DefaultTemplateRecordAddress?r.DefaultTemplateRecordAddress:"string"==typeof this.options.DefaultTemplateRecordAddress&&this.options.DefaultTemplateRecordAddress,h="string"==typeof a?this.pict.DataProvider.getDataByAddress(a):void 0),this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${o}] Destination[${l}] TemplateRecordAddress[${a}] renderAsync:`),this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);let c,d=this.fable.newAnticipate();d.anticipate((e=>{this.onBeforeRender(r,l,h),this.onBeforeRenderAsync(e)})),d.anticipate((t=>{this.pict.parseTemplateByHash(r.TemplateHash,h,((i,s)=>{if(i)return this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${o} (param ${e}) because it did not parse the template.`,i),t(i);switch(c=s,this.pict.LogNoisiness>0&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${o}] content length ${s.length} to Destination [${l}] using Async render method ${r.RenderMethod}.`),r.RenderMethod){case"append":this.pict.ContentAssignment.appendContent(l,s);break;case"prepend":this.pict.ContentAssignment.prependContent(l,s);break;case"append_once":this.pict.ContentAssignment.getElement(`${r.DestinationAddress}`).length<1&&this.pict.ContentAssignment.appendContent(l,s);default:this.pict.ContentAssignment.assignContent(l,s)}return this.lastRenderedTimestamp=this.pict.log.getTimeStamp(),t()}),[this])})),d.anticipate((e=>{this.onAfterRender(r,l,h,c),this.onAfterRenderAsync(e)})),d.wait(n)}renderDefaultAsync(e){this.renderAsync(e)}basicRender(e,t,i){let s=this.buildRenderOptions(e,t,i);return s.Valid?(this.assignRenderContent(s.Renderable,s.DestinationAddress,this.pict.parseTemplateByHash(s.Renderable.TemplateHash,s.Record,null,[this])),!0):(this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${s.RenderableHash} because it is not valid.`),!1)}basicRenderAsync(e,t,i,s){let o="function"==typeof s?s:"function"==typeof i?i:"function"==typeof t?t:"function"==typeof e&&e,n=this.buildRenderOptions(e,t,i);if(!n.Valid){let e=`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${n.RenderableHash} because it is not valid.`;return this.log.error(e),o(e)}this.pict.parseTemplateByHash(n.Renderable.TemplateHash,n.Record,((e,t)=>e?(this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${n.RenderableHash} because it did not parse the template.`,e),o(e)):(this.assignRenderContent(n.Renderable,n.DestinationAddress,t),o())),[this])}onAfterRender(e,t,i,s){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`),!0}onAfterRenderAsync(e){return e()}onBeforeSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`),!0}onBeforeSolveAsync(e){return this.onBeforeSolve(),e()}onSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`),!0}onSolveAsync(e){return this.onSolve(),e()}solve(){return this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`),this.onBeforeSolve(),this.onSolve(),this.onAfterSolve(),this.lastSolvedTimestamp=this.pict.log.getTimeStamp(),!0}solveAsync(e){let t=this.pict.instantiateServiceProviderWithoutRegistration("Anticipate"),i="function"==typeof e&&e;i||(this.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),i=e=>{e&&this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${e}`,e)}),t.anticipate(this.onBeforeSolveAsync.bind(this)),t.anticipate(this.onSolveAsync.bind(this)),t.anticipate(this.onAfterSolveAsync.bind(this)),t.wait((e=>(this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`),this.lastSolvedTimestamp=this.pict.log.getTimeStamp(),i(e))))}onAfterSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`),!0}onAfterSolveAsync(e){return this.onAfterSolve(),e()}onBeforeMarshalFromView(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`),!0}onBeforeMarshalFromViewAsync(e){return this.onBeforeMarshalFromView(),e()}onMarshalFromView(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`),!0}onMarshalFromViewAsync(e){return this.onMarshalFromView(),e()}marshalFromView(){return this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`),this.onBeforeMarshalFromView(),this.onMarshalFromView(),this.onAfterMarshalFromView(),this.lastMarshalFromViewTimestamp=this.pict.log.getTimeStamp(),!0}marshalFromViewAsync(e){let t=this.pict.instantiateServiceProviderWithoutRegistration("Anticipate"),i="function"==typeof e&&e;i||(this.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),i=e=>{e&&this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${e}`,e)}),t.anticipate(this.onBeforeMarshalFromViewAsync.bind(this)),t.anticipate(this.onMarshalFromViewAsync.bind(this)),t.anticipate(this.onAfterMarshalFromViewAsync.bind(this)),t.wait((e=>(this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`),this.lastMarshalFromViewTimestamp=this.pict.log.getTimeStamp(),i(e))))}onAfterMarshalFromView(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`),!0}onAfterMarshalFromViewAsync(e){return this.onAfterMarshalFromView(),e()}onBeforeMarshalToView(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`),!0}onBeforeMarshalToViewAsync(e){return this.onBeforeMarshalToView(),e()}onMarshalToView(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`),!0}onMarshalToViewAsync(e){return this.onMarshalToView(),e()}marshalToView(){return this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`),this.onBeforeMarshalToView(),this.onMarshalToView(),this.onAfterMarshalToView(),this.lastMarshalToViewTimestamp=this.pict.log.getTimeStamp(),!0}marshalToViewAsync(e){let t=this.pict.instantiateServiceProviderWithoutRegistration("Anticipate"),i="function"==typeof e&&e;i||(this.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),i=e=>{e&&this.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${e}`,e)}),t.anticipate(this.onBeforeMarshalToViewAsync.bind(this)),t.anticipate(this.onMarshalToViewAsync.bind(this)),t.anticipate(this.onAfterMarshalToViewAsync.bind(this)),t.wait((e=>(this.pict.LogNoisiness>2&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`),this.lastMarshalToViewTimestamp=this.pict.log.getTimeStamp(),i(e))))}onAfterMarshalToView(){return this.pict.LogNoisiness>3&&this.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`),!0}onAfterMarshalToViewAsync(e){return this.onAfterMarshalToView(),e()}get isPictView(){return!0}}},{"../package.json":3,"fable-serviceproviderbase":2}]},{},[4])(4)}));
//# sourceMappingURL=pict-view.min.js.map
