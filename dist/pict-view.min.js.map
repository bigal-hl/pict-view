{"version":3,"sources":["pict-view.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-View.js"],"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","r","e","Symbol","toPrimitive","call","TypeError","String","Number","f","exports","module","define","amd","window","global","self","this","PictView","n","o","c","require","u","a","Error","code","p","length","FableServiceProviderBase","constructor","pFable","pOptions","pServiceHash","isFable","connectFable","fable","UUID","getUUID","options","concat","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","libFableServiceBase","defaultPictViewSettings","DefaultRenderable","DefaultDestinationAddress","DefaultTemplateRecordAddress","ViewIdentifier","AutoInitialize","AutoInitializeOrdinal","AutoRender","AutoRenderOrdinal","AutoSolveWithApp","AutoSolveOrdinal","CSSHash","CSS","CSSProvider","CSSPriority","Templates","DefaultTemplates","Renderables","Manifests","super","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastRenderedTimestamp","lastMarshalFromViewTimestamp","lastMarshalToViewTimestamp","tmpTemplate","Source","TemplateProvider","addTemplate","Template","error","tmpDefaultTemplate","addDefaultTemplate","Prefix","Postfix","tmpCSSHash","tmpCSSProvider","CSSMap","addCSS","renderables","tmpRenderable","addRenderable","pRenderableHash","pTemplateHash","pDefaultTemplateRecordAddress","pDefaultDestinationAddress","pRenderMethod","RenderableHash","TemplateHash","ContentDestinationAddress","RenderMethod","LogNoisiness","trace","onBeforeInitialize","onBeforeInitializeAsync","fCallback","onInitialize","onInitializeAsync","initialize","LogControlFlow","warn","onAfterInitialize","getTimeStamp","initializeAsync","tmpAnticipate","instantiateServiceProviderWithoutRegistration","info","anticipate","bind","onAfterInitializeAsync","wait","pError","onBeforeRender","pRenderable","pRenderDestinationAddress","pRecord","onBeforeRenderAsync","buildRenderOptions","pTemplateRecordAddress","tmpRenderOptions","Valid","Renderable","DestinationAddress","RecordAddress","Record","tmpRecordAddress","DataProvider","getDataByAddress","undefined","assignRenderContent","pContent","ContentAssignment","appendContent","prependContent","getElement","assignContent","render","tmpRenderableHash","tmpRecord","tmpRenderDestinationAddress","tmpContent","parseTemplateByHash","onAfterRender","renderAsync","tmpCallback","Name","newAnticipate","fOnBeforeRenderCallback","fAsyncTemplateCallback","fOnAfterRenderCallback","onAfterRenderAsync","renderDefaultAsync","basicRender","basicRenderAsync","onBeforeSolve","onBeforeSolveAsync","onSolve","onSolveAsync","solve","onAfterSolve","solveAsync","onAfterSolveAsync","onBeforeMarshalFromView","onBeforeMarshalFromViewAsync","onMarshalFromView","onMarshalFromViewAsync","marshalFromView","onAfterMarshalFromView","marshalFromViewAsync","onAfterMarshalFromViewAsync","onBeforeMarshalToView","onBeforeMarshalToViewAsync","onMarshalToView","onMarshalToViewAsync","marshalToView","onAfterMarshalToView","marshalToViewAsync","onAfterMarshalToViewAsync","isPictView"],"mappings":"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","file":"pict-view.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictView = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{}],2:[function(require,module,exports){\n\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\t// If this is set to true, when the App initializes this will.\n\t\t// After the App initializes, initialize will be called as soon as it's added.\n\t\tAutoInitialize: true,\n\t\tAutoInitializeOrdinal: 0,\n\n\t\t// If this is set to true, when the App autorenders (on load) this will.\n\t\t// After the App initializes, render will be called as soon as it's added.\n\t\tAutoRender: true,\n\t\tAutoRenderOrdinal: 0,\n\n\t\tAutoSolveWithApp: true,\n\t\tAutoSolveOrdinal: 0,\n\n\t\tCSSHash: false,\n\t\tCSS: false,\n\t\tCSSProvider: false,\n\t\tCSSPriority: 500,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\n/** @typedef {(error?: Error) => void} ErrorCallback */\n/** @typedef {number | boolean} PictTimestamp */\n\n/**\n * @typedef {Object} Renderable\n *\n * @property {string} RenderableHash - A unique hash for the renderable.\n * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.\n * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.\n * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.\n * @property {string} [RenderMethod] - The method to use when rendering the renderable ('replace', 'append', 'prepend', 'append_once').\n */\n\n/**\n * Represents a view in the Pict ecosystem.\n */\nclass PictView extends libFableServiceBase\n{\n\t/**\n\t * @param {any} pFable - The Fable object that this service is attached to.\n\t * @param {any} [pOptions] - (optional) The options for this service.\n\t * @param {string} [pServiceHash] - (optional) The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\t//FIXME: add types to fable and ancillaries\n\t\t/** @type {any} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {String} */\n\t\tthis.UUID;\n\t\t/** @type {String} */\n\t\tthis.Hash;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t// Convenience and consistency naming\n\t\t/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.pict.AppData;\n\n\t\t/** @type {PictTimestamp} */\n\t\tthis.initializeTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastSolvedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastRenderedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalFromViewTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalToViewTimestamp = false;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!('Hash' in tmpTemplate) || !('Template' in tmpTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!('Postfix' in tmpDefaultTemplate) || !('Template' in tmpDefaultTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load the CSS if it's available\n\t\tif (this.options.CSS)\n\t\t{\n\t\t\tlet tmpCSSHash = this.options.CSSHash ? this.options.CSSHash : `View-${this.options.ViewIdentifier}`;\n\t\t\tlet tmpCSSProvider = this.options.CSSProvider ? this.options.CSSProvider : tmpCSSHash;\n\t\t\tthis.pict.CSSMap.addCSS(tmpCSSHash, this.options.CSS, tmpCSSProvider, this.options.CSSPriority);\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\t/** @type {Object<String, Renderable>} */\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\t/** @type {Renderable} */\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\t\t\tthis.addRenderable(tmpRenderable);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a renderable to the view.\n\t *\n\t * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.\n\t * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.\n\t * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.\n\t * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.\n\t * @param {string} [pRenderMethod] - (optional) The method to use when rendering the renderable (ex. 'replace').\n\t */\n\taddRenderable(pRenderableHash, pTemplateHash, pDefaultTemplateRecordAddress, pDefaultDestinationAddress, pRenderMethod)\n\t{\n\t\t/** @type {Renderable} */\n\t\tlet tmpRenderable;\n\n\t\tif (typeof(pRenderableHash) == 'object')\n\t\t{\n\t\t\t// The developer passed in the renderable as an object.\n\t\t\t// Use theirs instead!\n\t\t\ttmpRenderable = pRenderableHash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpRenderMethod = (typeof(pRenderMethod) !== 'string') ? pRenderMethod : 'replace';\n\t\t\ttmpRenderable = (\n\t\t\t\t{\n\t\t\t\t\tRenderableHash: pRenderableHash,\n\t\t\t\t\tTemplateHash: pTemplateHash,\n\t\t\t\t\tDefaultTemplateRecordAddress: pDefaultTemplateRecordAddress,\n\t\t\t\t\tContentDestinationAddress: pDefaultDestinationAddress,\n\t\t\t\t\tRenderMethod: tmpRenderMethod\n\t\t\t\t});\n\t\t}\n\n\t\tif ((typeof(tmpRenderable.RenderableHash) != 'string') || (typeof(tmpRenderable.TemplateHash) != 'string'))\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`, tmpRenderable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${tmpRenderable.RenderableHash}] pointed to template ${tmpRenderable.TemplateHash}.`);\n\t\t\t}\n\n\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                        Code Section: Initialization                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized.\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized.\n\t */\n\tonInitialize()\n\t{\n\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view initialization.\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\tthis.onAfterInitialize();\n\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Performs view initialization (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallback();\n\t\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Render                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that will be rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {any} [pRecord] - The record (data) that will be used to render the renderable.\n\t */\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pRecord)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Builds the render options for a renderable.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbuildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = {Valid: true};\n\t\ttmpRenderOptions.RenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t\t\t\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ?\n\t\t\t\t\t\t\t\tthis.options.DefaultRenderable : false;\n\t\tif (!tmpRenderOptions.RenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.Renderable = this.renderables[tmpRenderOptions.RenderableHash];\n\t\tif (!tmpRenderOptions.Renderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.DestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderOptions.Renderable.ContentDestinationAddress) === 'string') ? tmpRenderOptions.Renderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\t\tif (!tmpRenderOptions.DestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address (param ${pRenderDestinationAddress}).`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = 'Passed in as object';\n\t\t\ttmpRenderOptions.Record = pTemplateRecordAddress;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderOptions.Renderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderOptions.Renderable.DefaultTemplateRecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\t\t\ttmpRenderOptions.Record = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\treturn tmpRenderOptions;\n\t}\n\n\t/**\n\t * Assigns the content to the destination address.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {Renderable} pRenderable - The renderable to render.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {string} pContent - The content to render.\n\t * @returns {boolean} - Returns true if the content was assigned successfully.\n\t * @memberof PictView\n\t */\n\tassignRenderContent(pRenderable, pRenderDestinationAddress, pContent)\n\t{\n\t\t// Assign the content to the destination address\n\t\tswitch(pRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'prepend':\n\t\t\t\treturn this.pict.ContentAssignment.prependContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${pRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\treturn this.pict.ContentAssignment.assignContent(pRenderDestinationAddress, pContent);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string} [pRenderable] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t */\n\trender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] render:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${tmpRenderableHash}] to Destination [${tmpRenderDestinationAddress}]...`);\n\t\t}\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord, null, [this])\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${tmpContent.length} to Destination [${tmpRenderDestinationAddress}] using render method [${tmpRenderable.RenderMethod}].`);\n\t\t}\n\n\t\t// Assign the content to the destination address\n\t\tswitch(tmpRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'prepend':\n\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent)\n\n\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string | ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string | ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string | ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t */\n\trenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address.`);\n\t\t\treturn tmpCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] renderAsync:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.newAnticipate();\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnBeforeRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\t\t\t\tthis.onBeforeRenderAsync(fOnBeforeRenderCallback);\n\t\t\t});\n\n\t\tlet tmpContent;\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fAsyncTemplateCallback) =>\n\t\t\t{\n\t\t\t\t// Render the template (asynchronously)\n\t\t\t\tthis.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord,\n\t\t\t\t\t(pError, pContent) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderableHash}) because it did not parse the template.`, pError);\n\t\t\t\t\t\t\treturn fAsyncTemplateCallback(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpContent = pContent;\n\n\t\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${pContent.length} to Destination [${tmpRenderDestinationAddress}] using Async render method ${tmpRenderable.RenderMethod}.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Assign the content to the destination address\n\t\t\t\t\t\tswitch(tmpRenderable.RenderMethod)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'append':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prepend':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'append_once':\n\t\t\t\t\t\t\t\t// Try to find the content in the destination address\n\t\t\t\t\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\t\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 'replace':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute the developer-overridable asynchronous post-render behavior\n\t\t\t\t\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\t\treturn fAsyncTemplateCallback();\n\t\t\t\t\t}, [this]);\n\t\t\t});\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnAfterRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\t\t\t\tthis.onAfterRenderAsync(fOnAfterRenderCallback);\n\t\t\t});\n\n\t\ttmpAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * Renders the default renderable.\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\trenderDefaultAsync(fCallback)\n\t{\n\t\t// Render the default renderable\n\t\tthis.renderAsync(fCallback);\n\t}\n\n\tbasicRender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record, null, [this]));\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbasicRenderAsync(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderable) === 'function') ? pRenderable :\n\t\t\t\t\t\t\tfalse;\n\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record,\n\t\t\t\t(pError, pContent) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderOptions.RenderableHash} because it did not parse the template.`, pError);\n\t\t\t\t\t\treturn tmpCallback(pError);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, pContent);\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t}, [this])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`;\n\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\treturn tmpCallback(tmpErrorMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that was rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable was rendered.\n\t * @param {any} [pRecord] - The record (data) that was used by the renderable.\n\t * @param {string} [pContent] - The content that was rendered.\n\t */\n\tonAfterRender(pRenderable, pRenderDestinationAddress, pRecord, pContent)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Solver                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is solved.\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved.\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks.\n\t *\n\t * @return {boolean} - True if the view was solved successfully, false otherwise.\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved.\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal From View                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tonBeforeMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view.\n\t */\n\tonMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalFromViewAsync(fCallback)\n\t{\n\n\t\tthis.onMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalFromView();\n\t\tthis.onMarshalFromView();\n\t\tthis.onAfterMarshalFromView();\n\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalFromViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view.\n\t */\n\tonAfterMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal To View                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view.\n\t */\n\tonBeforeMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view.\n\t */\n\tonMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data into the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalToView();\n\t\tthis.onMarshalToView();\n\t\tthis.onAfterMarshalToView();\n\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalToViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view.\n\t */\n\tonAfterMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/** @return {boolean} - True if the object is a PictView. */\n\tget isPictView()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictView;\n\n},{\"fable-serviceproviderbase\":1}]},{},[2])(2)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\t// If this is set to true, when the App initializes this will.\n\t\t// After the App initializes, initialize will be called as soon as it's added.\n\t\tAutoInitialize: true,\n\t\tAutoInitializeOrdinal: 0,\n\n\t\t// If this is set to true, when the App autorenders (on load) this will.\n\t\t// After the App initializes, render will be called as soon as it's added.\n\t\tAutoRender: true,\n\t\tAutoRenderOrdinal: 0,\n\n\t\tAutoSolveWithApp: true,\n\t\tAutoSolveOrdinal: 0,\n\n\t\tCSSHash: false,\n\t\tCSS: false,\n\t\tCSSProvider: false,\n\t\tCSSPriority: 500,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\n/** @typedef {(error?: Error) => void} ErrorCallback */\n/** @typedef {number | boolean} PictTimestamp */\n\n/**\n * @typedef {Object} Renderable\n *\n * @property {string} RenderableHash - A unique hash for the renderable.\n * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.\n * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.\n * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.\n * @property {string} [RenderMethod] - The method to use when rendering the renderable ('replace', 'append', 'prepend', 'append_once').\n */\n\n/**\n * Represents a view in the Pict ecosystem.\n */\nclass PictView extends libFableServiceBase\n{\n\t/**\n\t * @param {any} pFable - The Fable object that this service is attached to.\n\t * @param {any} [pOptions] - (optional) The options for this service.\n\t * @param {string} [pServiceHash] - (optional) The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\t//FIXME: add types to fable and ancillaries\n\t\t/** @type {any} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {String} */\n\t\tthis.UUID;\n\t\t/** @type {String} */\n\t\tthis.Hash;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t// Convenience and consistency naming\n\t\t/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.pict.AppData;\n\n\t\t/** @type {PictTimestamp} */\n\t\tthis.initializeTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastSolvedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastRenderedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalFromViewTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalToViewTimestamp = false;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!('Hash' in tmpTemplate) || !('Template' in tmpTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!('Postfix' in tmpDefaultTemplate) || !('Template' in tmpDefaultTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load the CSS if it's available\n\t\tif (this.options.CSS)\n\t\t{\n\t\t\tlet tmpCSSHash = this.options.CSSHash ? this.options.CSSHash : `View-${this.options.ViewIdentifier}`;\n\t\t\tlet tmpCSSProvider = this.options.CSSProvider ? this.options.CSSProvider : tmpCSSHash;\n\t\t\tthis.pict.CSSMap.addCSS(tmpCSSHash, this.options.CSS, tmpCSSProvider, this.options.CSSPriority);\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\t/** @type {Object<String, Renderable>} */\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\t/** @type {Renderable} */\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\t\t\tthis.addRenderable(tmpRenderable);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a renderable to the view.\n\t *\n\t * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.\n\t * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.\n\t * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.\n\t * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.\n\t * @param {string} [pRenderMethod] - (optional) The method to use when rendering the renderable (ex. 'replace').\n\t */\n\taddRenderable(pRenderableHash, pTemplateHash, pDefaultTemplateRecordAddress, pDefaultDestinationAddress, pRenderMethod)\n\t{\n\t\t/** @type {Renderable} */\n\t\tlet tmpRenderable;\n\n\t\tif (typeof(pRenderableHash) == 'object')\n\t\t{\n\t\t\t// The developer passed in the renderable as an object.\n\t\t\t// Use theirs instead!\n\t\t\ttmpRenderable = pRenderableHash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpRenderMethod = (typeof(pRenderMethod) !== 'string') ? pRenderMethod : 'replace';\n\t\t\ttmpRenderable = (\n\t\t\t\t{\n\t\t\t\t\tRenderableHash: pRenderableHash,\n\t\t\t\t\tTemplateHash: pTemplateHash,\n\t\t\t\t\tDefaultTemplateRecordAddress: pDefaultTemplateRecordAddress,\n\t\t\t\t\tContentDestinationAddress: pDefaultDestinationAddress,\n\t\t\t\t\tRenderMethod: tmpRenderMethod\n\t\t\t\t});\n\t\t}\n\n\t\tif ((typeof(tmpRenderable.RenderableHash) != 'string') || (typeof(tmpRenderable.TemplateHash) != 'string'))\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`, tmpRenderable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${tmpRenderable.RenderableHash}] pointed to template ${tmpRenderable.TemplateHash}.`);\n\t\t\t}\n\n\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                        Code Section: Initialization                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized.\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized.\n\t */\n\tonInitialize()\n\t{\n\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view initialization.\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\tthis.onAfterInitialize();\n\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Performs view initialization (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallback();\n\t\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Render                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that will be rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {any} [pRecord] - The record (data) that will be used to render the renderable.\n\t */\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pRecord)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Builds the render options for a renderable.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbuildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = {Valid: true};\n\t\ttmpRenderOptions.RenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t\t\t\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ?\n\t\t\t\t\t\t\t\tthis.options.DefaultRenderable : false;\n\t\tif (!tmpRenderOptions.RenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.Renderable = this.renderables[tmpRenderOptions.RenderableHash];\n\t\tif (!tmpRenderOptions.Renderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.DestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderOptions.Renderable.ContentDestinationAddress) === 'string') ? tmpRenderOptions.Renderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\t\tif (!tmpRenderOptions.DestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address (param ${pRenderDestinationAddress}).`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = 'Passed in as object';\n\t\t\ttmpRenderOptions.Record = pTemplateRecordAddress;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderOptions.Renderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderOptions.Renderable.DefaultTemplateRecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\t\t\ttmpRenderOptions.Record = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\treturn tmpRenderOptions;\n\t}\n\n\t/**\n\t * Assigns the content to the destination address.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {Renderable} pRenderable - The renderable to render.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {string} pContent - The content to render.\n\t * @returns {boolean} - Returns true if the content was assigned successfully.\n\t * @memberof PictView\n\t */\n\tassignRenderContent(pRenderable, pRenderDestinationAddress, pContent)\n\t{\n\t\t// Assign the content to the destination address\n\t\tswitch(pRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'prepend':\n\t\t\t\treturn this.pict.ContentAssignment.prependContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${pRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\treturn this.pict.ContentAssignment.assignContent(pRenderDestinationAddress, pContent);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string} [pRenderable] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t */\n\trender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] render:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${tmpRenderableHash}] to Destination [${tmpRenderDestinationAddress}]...`);\n\t\t}\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord, null, [this])\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${tmpContent.length} to Destination [${tmpRenderDestinationAddress}] using render method [${tmpRenderable.RenderMethod}].`);\n\t\t}\n\n\t\t// Assign the content to the destination address\n\t\tswitch(tmpRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'prepend':\n\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent)\n\n\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string | ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string | ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string | ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t */\n\trenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address.`);\n\t\t\treturn tmpCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] renderAsync:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.newAnticipate();\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnBeforeRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\t\t\t\tthis.onBeforeRenderAsync(fOnBeforeRenderCallback);\n\t\t\t});\n\n\t\tlet tmpContent;\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fAsyncTemplateCallback) =>\n\t\t\t{\n\t\t\t\t// Render the template (asynchronously)\n\t\t\t\tthis.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord,\n\t\t\t\t\t(pError, pContent) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderableHash}) because it did not parse the template.`, pError);\n\t\t\t\t\t\t\treturn fAsyncTemplateCallback(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpContent = pContent;\n\n\t\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${pContent.length} to Destination [${tmpRenderDestinationAddress}] using Async render method ${tmpRenderable.RenderMethod}.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Assign the content to the destination address\n\t\t\t\t\t\tswitch(tmpRenderable.RenderMethod)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'append':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prepend':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'append_once':\n\t\t\t\t\t\t\t\t// Try to find the content in the destination address\n\t\t\t\t\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\t\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 'replace':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute the developer-overridable asynchronous post-render behavior\n\t\t\t\t\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\t\treturn fAsyncTemplateCallback();\n\t\t\t\t\t}, [this]);\n\t\t\t});\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnAfterRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\t\t\t\tthis.onAfterRenderAsync(fOnAfterRenderCallback);\n\t\t\t});\n\n\t\ttmpAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * Renders the default renderable.\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\trenderDefaultAsync(fCallback)\n\t{\n\t\t// Render the default renderable\n\t\tthis.renderAsync(fCallback);\n\t}\n\n\tbasicRender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record, null, [this]));\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbasicRenderAsync(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderable) === 'function') ? pRenderable :\n\t\t\t\t\t\t\tfalse;\n\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record,\n\t\t\t\t(pError, pContent) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderOptions.RenderableHash} because it did not parse the template.`, pError);\n\t\t\t\t\t\treturn tmpCallback(pError);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, pContent);\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t}, [this])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`;\n\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\treturn tmpCallback(tmpErrorMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that was rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable was rendered.\n\t * @param {any} [pRecord] - The record (data) that was used by the renderable.\n\t * @param {string} [pContent] - The content that was rendered.\n\t */\n\tonAfterRender(pRenderable, pRenderDestinationAddress, pRecord, pContent)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Solver                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is solved.\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved.\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks.\n\t *\n\t * @return {boolean} - True if the view was solved successfully, false otherwise.\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved.\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal From View                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tonBeforeMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view.\n\t */\n\tonMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalFromViewAsync(fCallback)\n\t{\n\n\t\tthis.onMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalFromView();\n\t\tthis.onMarshalFromView();\n\t\tthis.onAfterMarshalFromView();\n\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalFromViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view.\n\t */\n\tonAfterMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal To View                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view.\n\t */\n\tonBeforeMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view.\n\t */\n\tonMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data into the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalToView();\n\t\tthis.onMarshalToView();\n\t\tthis.onAfterMarshalToView();\n\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalToViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view.\n\t */\n\tonAfterMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/** @return {boolean} - True if the object is a PictView. */\n\tget isPictView()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictView;\n"]}