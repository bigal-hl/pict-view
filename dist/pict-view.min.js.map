{"version":3,"sources":["pict-view.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase-Preinit.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-View.js"],"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","f","exports","module","define","amd","window","global","self","this","PictView","r","e","n","t","o","i","c","require","u","a","Error","code","p","length","FableCoreServiceProviderBase","constructor","pOptions","pServiceHash","fable","options","serviceType","UUID","concat","Math","floor","random","Hash","connectFable","pFable","FableServiceProviderBase","isFable","getUUID","log","servicesMap","services","CoreServiceProviderBase","libFableServiceBase","defaultPictViewSettings","DefaultRenderable","DefaultDestinationAddress","DefaultTemplateRecordAddress","ViewIdentifier","InitializeOnLoad","RenderOnLoad","Templates","DefaultTemplates","Renderables","Manifests","super","assign","JSON","parse","stringify","pict","AppData","tmpTemplate","hasOwnProperty","Source","TemplateProvider","addTemplate","Template","error","tmpDefaultTemplate","addDefaultTemplate","Prefix","Postfix","renderables","tmpRenderable","RenderableHash","onBeforeSolve","info","onBeforeSolveAsync","fCallback","onSolve","onSolveAsync","solve","solveAsync","tmpAnticipate","serviceManager","instantiateServiceProviderWithoutRegistration","anticipate","bind","onAfterSolve","wait","pError","onAfterSolveAsync","onBeforeInitialize","onBeforeInitializeAsync","onInitialize","onInitializeAsync","initialize","onAfterInitialize","initializeAsync","fCallBack","onAfterInitializeAsync","onBeforeRender","pRenderable","pRenderDestinationAddress","pData","onBeforeRenderAsync","render","pTemplateDataAddress","tmpRenderableHash","tmpRenderDestinationAddress","ContentDestinationAddress","tmpDataAddress","RecordAddress","tmpData","DataProvider","getDataByAddress","tmpContent","parseTemplateByHash","TemplateHash","ContentAssignment","assignContent","onAfterRender","renderAsync","pContent","onAfterRenderAsync"],"mappings":"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","file":"pict-view.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictView = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');\n},{\"./Fable-ServiceProviderBase-Preinit.js\":1}],3:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\tInitializeOnLoad: true,\n\t\tRenderOnLoad: true,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\nclass PictView extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!tmpTemplate.hasOwnProperty('Hash') || !tmpTemplate.hasOwnProperty('Template'))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.fable.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!tmpDefaultTemplate.hasOwnProperty('Postfix') || !tmpDefaultTemplate.hasOwnProperty('Template'))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.fable.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\n\t\t\tif (!tmpRenderable.hasOwnProperty('RenderableHash') || !tmpRenderable.hasOwnProperty('TemplateHash'))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable ${i} in the options array.`, tmpRenderable);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t\t}\n\t\t}\n\t}\n\n    onBeforeSolve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n        return true;\n    }\n    onBeforeSolveAsync(fCallback)\n    {\n        this.onBeforeSolve();\n        return fCallback();\n    }\n\n    onSolve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n        return true;\n    }\n    onSolveAsync(fCallback)\n    {\n        this.onSolve();\n        return fCallback();\n    }\n\n    // TODO: do we need an asynchronous version of this?\n    solve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`)\n        return true;\n    }\n\n    solveAsync(fCallback)\n    {\n        let tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n        tmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n        tmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n        tmpAnticipate.anticipate(this.onAfterSolve.bind(this));\n\n        tmpAnticipate.wait(\n            (pError) =>\n            {\n                this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n                return fCallback(pError);\n            });\n    }\n\n    onAfterSolve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n        return true;\n    }\n    onAfterSolveAsync(fCallback)\n    {\n        this.onAfterSolve();\n        return fCallback();\n    }\n\n\tonBeforeInitialize()\n\t{\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tthis.onBeforeInitialize();\n\t\tthis.onInitialize();\n\t\tthis.onAfterInitialize();\n\t\treturn true;\n\t}\n\tinitializeAsync(fCallBack)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\n\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\treturn fCallBack();\n\t\t\t})\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pData)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\treturn true;\n\t}\n\tonBeforeRenderAsync(pRenderable, pRenderDestinationAddress, pData, fCallback)\n\t{\n\t\tthis.onBeforeRender(pRenderable, pRenderDestinationAddress, pData);\n\t\treturn fCallback();\n\t}\n\n\trender(pRenderable, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpDataAddress = (typeof (pTemplateDataAddress) === 'string') ? pTemplateDataAddress :\n\t\t\t(typeof (tmpRenderable.RecordAddress) === 'string') ? tmpRenderable.RecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\tlet tmpData = (typeof (tmpDataAddress) === 'string') ? this.fable.DataProvider.getDataByAddress(tmpDataAddress) : undefined;\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpData);\n\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.fable.parseTemplateByHash(tmpRenderable.TemplateHash, tmpData)\n\n\t\t// Assign the content to the destination address\n\t\tthis.fable.ContentAssignment.assignContent(tmpRenderDestinationAddress, tmpContent);\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpData, tmpContent)\n\t}\n\trenderAsync(pRenderable, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderable}because it is not a valid renderable.`);\n\t\t\treturn fCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderable}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn fCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn fCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpDataAddress = (typeof (pTemplateDataAddress) === 'string') ? pTemplateDataAddress :\n\t\t\t(typeof (tmpRenderable.RecordAddress) === 'string') ? tmpRenderable.RecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\tlet tmpData = (typeof (tmpDataAddress) === 'string') ? this.fable.DataProvider.getDataByAddress(tmpDataAddress) : undefined;\n\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpData);\n\n\t\t// Render the template (asynchronously)\n\t\tthis.fable.parseTemplateByHash(tmpRenderable.TemplateHash, tmpData,\n\t\t\t(pError, pContent) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderable}) because it did not parse the template.`, pError);\n\t\t\t\t\treturn fCallback(pError);\n\t\t\t\t}\n\n\t\t\t\t// Assign the content to the destination address\n\t\t\t\tthis.fable.ContentAssignment.assignContent(tmpRenderDestinationAddress, pContent);\n\n\t\t\t\t// Execute the developer-overridable post-render behavior\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpData, pContent)\n\n\t\t\t\treturn fCallback(null, pContent);\n\t\t\t});\n\t}\n\n\tonAfterRender()\n\t{\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\treturn true;\n\t}\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n}\n\nmodule.exports = PictView;\n},{\"fable-serviceproviderbase\":2}]},{},[3])(3)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');","const libFableServiceBase = require('fable-serviceproviderbase');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\tInitializeOnLoad: true,\n\t\tRenderOnLoad: true,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\nclass PictView extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!tmpTemplate.hasOwnProperty('Hash') || !tmpTemplate.hasOwnProperty('Template'))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.fable.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!tmpDefaultTemplate.hasOwnProperty('Postfix') || !tmpDefaultTemplate.hasOwnProperty('Template'))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.fable.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\n\t\t\tif (!tmpRenderable.hasOwnProperty('RenderableHash') || !tmpRenderable.hasOwnProperty('TemplateHash'))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable ${i} in the options array.`, tmpRenderable);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t\t}\n\t\t}\n\t}\n\n    onBeforeSolve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n        return true;\n    }\n    onBeforeSolveAsync(fCallback)\n    {\n        this.onBeforeSolve();\n        return fCallback();\n    }\n\n    onSolve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n        return true;\n    }\n    onSolveAsync(fCallback)\n    {\n        this.onSolve();\n        return fCallback();\n    }\n\n    // TODO: do we need an asynchronous version of this?\n    solve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`)\n        return true;\n    }\n\n    solveAsync(fCallback)\n    {\n        let tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n        tmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n        tmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n        tmpAnticipate.anticipate(this.onAfterSolve.bind(this));\n\n        tmpAnticipate.wait(\n            (pError) =>\n            {\n                this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n                return fCallback(pError);\n            });\n    }\n\n    onAfterSolve()\n    {\n        this.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n        return true;\n    }\n    onAfterSolveAsync(fCallback)\n    {\n        this.onAfterSolve();\n        return fCallback();\n    }\n\n\tonBeforeInitialize()\n\t{\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tthis.onBeforeInitialize();\n\t\tthis.onInitialize();\n\t\tthis.onAfterInitialize();\n\t\treturn true;\n\t}\n\tinitializeAsync(fCallBack)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\n\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\treturn fCallBack();\n\t\t\t})\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pData)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\treturn true;\n\t}\n\tonBeforeRenderAsync(pRenderable, pRenderDestinationAddress, pData, fCallback)\n\t{\n\t\tthis.onBeforeRender(pRenderable, pRenderDestinationAddress, pData);\n\t\treturn fCallback();\n\t}\n\n\trender(pRenderable, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpDataAddress = (typeof (pTemplateDataAddress) === 'string') ? pTemplateDataAddress :\n\t\t\t(typeof (tmpRenderable.RecordAddress) === 'string') ? tmpRenderable.RecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\tlet tmpData = (typeof (tmpDataAddress) === 'string') ? this.fable.DataProvider.getDataByAddress(tmpDataAddress) : undefined;\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpData);\n\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.fable.parseTemplateByHash(tmpRenderable.TemplateHash, tmpData)\n\n\t\t// Assign the content to the destination address\n\t\tthis.fable.ContentAssignment.assignContent(tmpRenderDestinationAddress, tmpContent);\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpData, tmpContent)\n\t}\n\trenderAsync(pRenderable, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderable}because it is not a valid renderable.`);\n\t\t\treturn fCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderable}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn fCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn fCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpDataAddress = (typeof (pTemplateDataAddress) === 'string') ? pTemplateDataAddress :\n\t\t\t(typeof (tmpRenderable.RecordAddress) === 'string') ? tmpRenderable.RecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\tlet tmpData = (typeof (tmpDataAddress) === 'string') ? this.fable.DataProvider.getDataByAddress(tmpDataAddress) : undefined;\n\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpData);\n\n\t\t// Render the template (asynchronously)\n\t\tthis.fable.parseTemplateByHash(tmpRenderable.TemplateHash, tmpData,\n\t\t\t(pError, pContent) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderable}) because it did not parse the template.`, pError);\n\t\t\t\t\treturn fCallback(pError);\n\t\t\t\t}\n\n\t\t\t\t// Assign the content to the destination address\n\t\t\t\tthis.fable.ContentAssignment.assignContent(tmpRenderDestinationAddress, pContent);\n\n\t\t\t\t// Execute the developer-overridable post-render behavior\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpData, pContent)\n\n\t\t\t\treturn fCallback(null, pContent);\n\t\t\t});\n\t}\n\n\tonAfterRender()\n\t{\n\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\treturn true;\n\t}\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n}\n\nmodule.exports = PictView;"]}