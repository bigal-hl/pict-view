{"version":3,"sources":["pict-view.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-View.js"],"names":["_callSuper","t","o","e","_getPrototypeOf","_possibleConstructorReturn","_isNativeReflectConstruct","Reflect","construct","constructor","apply","self","call","_typeof","TypeError","_assertThisInitialized","ReferenceError","Boolean","prototype","valueOf","Object","setPrototypeOf","getPrototypeOf","bind","__proto__","_inherits","subClass","superClass","create","value","writable","configurable","defineProperty","_setPrototypeOf","p","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","length","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","_toPrimitive","r","Symbol","toPrimitive","String","Number","iterator","f","exports","module","define","amd","window","global","this","PictView","n","c","require","u","a","Error","code","FableServiceProviderBase","pFable","pOptions","pServiceHash","isFable","connectFable","fable","UUID","getUUID","options","concat","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","libFableServiceBase","defaultPictViewSettings","DefaultRenderable","DefaultDestinationAddress","DefaultTemplateRecordAddress","ViewIdentifier","AutoInitialize","AutoInitializeOrdinal","AutoRender","AutoRenderOrdinal","AutoSolveWithApp","AutoSolveOrdinal","CSSHash","CSS","CSSProvider","CSSPriority","Templates","DefaultTemplates","Renderables","Manifests","_libFableServiceBase","_this","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastRenderedTimestamp","lastMarshalFromViewTimestamp","lastMarshalToViewTimestamp","tmpTemplate","Source","TemplateProvider","addTemplate","Template","error","tmpDefaultTemplate","addDefaultTemplate","Prefix","Postfix","tmpCSSHash","tmpCSSProvider","CSSMap","addCSS","renderables","tmpRenderable","addRenderable","pRenderableHash","pTemplateHash","pDefaultTemplateRecordAddress","pDefaultDestinationAddress","pRenderMethod","RenderableHash","TemplateHash","ContentDestinationAddress","RenderMethod","LogNoisiness","trace","fCallback","onBeforeInitialize","onInitialize","LogControlFlow","warn","onAfterInitialize","getTimeStamp","_this2","tmpAnticipate","instantiateServiceProviderWithoutRegistration","info","anticipate","onBeforeInitializeAsync","onInitializeAsync","onAfterInitializeAsync","wait","pError","pRenderable","pRenderDestinationAddress","pRecord","pTemplateRecordAddress","tmpRenderOptions","Valid","Renderable","DestinationAddress","RecordAddress","Record","tmpRecordAddress","DataProvider","getDataByAddress","undefined","pContent","ContentAssignment","appendContent","prependContent","getElement","assignContent","tmpRenderableHash","tmpRecord","tmpRenderDestinationAddress","onBeforeRender","tmpContent","parseTemplateByHash","onAfterRender","_this3","tmpCallback","Name","newAnticipate","fOnBeforeRenderCallback","onBeforeRenderAsync","fAsyncTemplateCallback","fOnAfterRenderCallback","onAfterRenderAsync","renderAsync","buildRenderOptions","assignRenderContent","_this4","onBeforeSolve","onSolve","onAfterSolve","_this5","onBeforeSolveAsync","onSolveAsync","onAfterSolveAsync","onBeforeMarshalFromView","onMarshalFromView","onAfterMarshalFromView","_this6","onBeforeMarshalFromViewAsync","onMarshalFromViewAsync","onAfterMarshalFromViewAsync","onBeforeMarshalToView","onMarshalToView","onAfterMarshalToView","_this7","onBeforeMarshalToViewAsync","onMarshalToViewAsync","onAfterMarshalToViewAsync","get"],"mappings":"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","file":"pict-view.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictView = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{}],2:[function(require,module,exports){\n\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\t// If this is set to true, when the App initializes this will.\n\t\t// After the App initializes, initialize will be called as soon as it's added.\n\t\tAutoInitialize: true,\n\t\tAutoInitializeOrdinal: 0,\n\n\t\t// If this is set to true, when the App autorenders (on load) this will.\n\t\t// After the App initializes, render will be called as soon as it's added.\n\t\tAutoRender: true,\n\t\tAutoRenderOrdinal: 0,\n\n\t\tAutoSolveWithApp: true,\n\t\tAutoSolveOrdinal: 0,\n\n\t\tCSSHash: false,\n\t\tCSS: false,\n\t\tCSSProvider: false,\n\t\tCSSPriority: 500,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\n/** @typedef {(error?: Error) => void} ErrorCallback */\n/** @typedef {number | boolean} PictTimestamp */\n\n/**\n * @typedef {Object} Renderable\n *\n * @property {string} RenderableHash - A unique hash for the renderable.\n * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.\n * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.\n * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.\n * @property {string} [RenderMethod] - The method to use when rendering the renderable ('replace', 'append', 'prepend', 'append_once').\n */\n\n/**\n * Represents a view in the Pict ecosystem.\n */\nclass PictView extends libFableServiceBase\n{\n\t/**\n\t * @param {any} pFable - The Fable object that this service is attached to.\n\t * @param {any} [pOptions] - (optional) The options for this service.\n\t * @param {string} [pServiceHash] - (optional) The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\t//FIXME: add types to fable and ancillaries\n\t\t/** @type {any} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {String} */\n\t\tthis.UUID;\n\t\t/** @type {String} */\n\t\tthis.Hash;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t// Convenience and consistency naming\n\t\t/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.pict.AppData;\n\n\t\t/** @type {PictTimestamp} */\n\t\tthis.initializeTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastSolvedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastRenderedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalFromViewTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalToViewTimestamp = false;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!('Hash' in tmpTemplate) || !('Template' in tmpTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!('Postfix' in tmpDefaultTemplate) || !('Template' in tmpDefaultTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load the CSS if it's available\n\t\tif (this.options.CSS)\n\t\t{\n\t\t\tlet tmpCSSHash = this.options.CSSHash ? this.options.CSSHash : `View-${this.options.ViewIdentifier}`;\n\t\t\tlet tmpCSSProvider = this.options.CSSProvider ? this.options.CSSProvider : tmpCSSHash;\n\t\t\tthis.pict.CSSMap.addCSS(tmpCSSHash, this.options.CSS, tmpCSSProvider, this.options.CSSPriority);\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\t/** @type {Object<String, Renderable>} */\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\t/** @type {Renderable} */\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\t\t\tthis.addRenderable(tmpRenderable);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a renderable to the view.\n\t *\n\t * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.\n\t * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.\n\t * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.\n\t * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.\n\t * @param {string} [pRenderMethod] - (optional) The method to use when rendering the renderable (ex. 'replace').\n\t */\n\taddRenderable(pRenderableHash, pTemplateHash, pDefaultTemplateRecordAddress, pDefaultDestinationAddress, pRenderMethod)\n\t{\n\t\t/** @type {Renderable} */\n\t\tlet tmpRenderable;\n\n\t\tif (typeof(pRenderableHash) == 'object')\n\t\t{\n\t\t\t// The developer passed in the renderable as an object.\n\t\t\t// Use theirs instead!\n\t\t\ttmpRenderable = pRenderableHash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpRenderMethod = (typeof(pRenderMethod) !== 'string') ? pRenderMethod : 'replace';\n\t\t\ttmpRenderable = (\n\t\t\t\t{\n\t\t\t\t\tRenderableHash: pRenderableHash,\n\t\t\t\t\tTemplateHash: pTemplateHash,\n\t\t\t\t\tDefaultTemplateRecordAddress: pDefaultTemplateRecordAddress,\n\t\t\t\t\tContentDestinationAddress: pDefaultDestinationAddress,\n\t\t\t\t\tRenderMethod: tmpRenderMethod\n\t\t\t\t});\n\t\t}\n\n\t\tif ((typeof(tmpRenderable.RenderableHash) != 'string') || (typeof(tmpRenderable.TemplateHash) != 'string'))\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`, tmpRenderable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${tmpRenderable.RenderableHash}] pointed to template ${tmpRenderable.TemplateHash}.`);\n\t\t\t}\n\n\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                        Code Section: Initialization                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized.\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized.\n\t */\n\tonInitialize()\n\t{\n\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view initialization.\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\tthis.onAfterInitialize();\n\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Performs view initialization (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallback();\n\t\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Render                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that will be rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {any} [pRecord] - The record (data) that will be used to render the renderable.\n\t */\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pRecord)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Builds the render options for a renderable.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbuildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = {Valid: true};\n\t\ttmpRenderOptions.RenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t\t\t\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ?\n\t\t\t\t\t\t\t\tthis.options.DefaultRenderable : false;\n\t\tif (!tmpRenderOptions.RenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.Renderable = this.renderables[tmpRenderOptions.RenderableHash];\n\t\tif (!tmpRenderOptions.Renderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.DestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderOptions.Renderable.ContentDestinationAddress) === 'string') ? tmpRenderOptions.Renderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\t\tif (!tmpRenderOptions.DestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address (param ${pRenderDestinationAddress}).`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = 'Passed in as object';\n\t\t\ttmpRenderOptions.Record = pTemplateRecordAddress;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderOptions.Renderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderOptions.Renderable.DefaultTemplateRecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\t\t\ttmpRenderOptions.Record = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\treturn tmpRenderOptions;\n\t}\n\n\t/**\n\t * Assigns the content to the destination address.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {Renderable} pRenderable - The renderable to render.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {string} pContent - The content to render.\n\t * @returns {boolean} - Returns true if the content was assigned successfully.\n\t * @memberof PictView\n\t */\n\tassignRenderContent(pRenderable, pRenderDestinationAddress, pContent)\n\t{\n\t\t// Assign the content to the destination address\n\t\tswitch(pRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'prepend':\n\t\t\t\treturn this.pict.ContentAssignment.prependContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${pRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\treturn this.pict.ContentAssignment.assignContent(pRenderDestinationAddress, pContent);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string} [pRenderable] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t */\n\trender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] render:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${tmpRenderableHash}] to Destination [${tmpRenderDestinationAddress}]...`);\n\t\t}\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord, null, [this])\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${tmpContent.length} to Destination [${tmpRenderDestinationAddress}] using render method [${tmpRenderable.RenderMethod}].`);\n\t\t}\n\n\t\t// Assign the content to the destination address\n\t\tswitch(tmpRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'prepend':\n\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent)\n\n\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string | ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string | ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string | ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t */\n\trenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address.`);\n\t\t\treturn tmpCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] renderAsync:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.newAnticipate();\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnBeforeRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\t\t\t\tthis.onBeforeRenderAsync(fOnBeforeRenderCallback);\n\t\t\t});\n\n\t\tlet tmpContent;\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fAsyncTemplateCallback) =>\n\t\t\t{\n\t\t\t\t// Render the template (asynchronously)\n\t\t\t\tthis.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord,\n\t\t\t\t\t(pError, pContent) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderableHash}) because it did not parse the template.`, pError);\n\t\t\t\t\t\t\treturn fAsyncTemplateCallback(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpContent = pContent;\n\n\t\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${pContent.length} to Destination [${tmpRenderDestinationAddress}] using Async render method ${tmpRenderable.RenderMethod}.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Assign the content to the destination address\n\t\t\t\t\t\tswitch(tmpRenderable.RenderMethod)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'append':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prepend':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'append_once':\n\t\t\t\t\t\t\t\t// Try to find the content in the destination address\n\t\t\t\t\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\t\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 'replace':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute the developer-overridable asynchronous post-render behavior\n\t\t\t\t\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\t\treturn fAsyncTemplateCallback();\n\t\t\t\t\t}, [this]);\n\t\t\t});\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnAfterRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\t\t\t\tthis.onAfterRenderAsync(fOnAfterRenderCallback);\n\t\t\t});\n\n\t\ttmpAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * Renders the default renderable.\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\trenderDefaultAsync(fCallback)\n\t{\n\t\t// Render the default renderable\n\t\tthis.renderAsync(fCallback);\n\t}\n\n\tbasicRender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record, null, [this]));\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbasicRenderAsync(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderable) === 'function') ? pRenderable :\n\t\t\t\t\t\t\tfalse;\n\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record,\n\t\t\t\t(pError, pContent) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderOptions.RenderableHash} because it did not parse the template.`, pError);\n\t\t\t\t\t\treturn tmpCallback(pError);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, pContent);\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t}, [this])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`;\n\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\treturn tmpCallback(tmpErrorMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that was rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable was rendered.\n\t * @param {any} [pRecord] - The record (data) that was used by the renderable.\n\t * @param {string} [pContent] - The content that was rendered.\n\t */\n\tonAfterRender(pRenderable, pRenderDestinationAddress, pRecord, pContent)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Solver                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is solved.\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved.\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks.\n\t *\n\t * @return {boolean} - True if the view was solved successfully, false otherwise.\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved.\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal From View                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tonBeforeMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view.\n\t */\n\tonMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalFromViewAsync(fCallback)\n\t{\n\n\t\tthis.onMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalFromView();\n\t\tthis.onMarshalFromView();\n\t\tthis.onAfterMarshalFromView();\n\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalFromViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view.\n\t */\n\tonAfterMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal To View                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view.\n\t */\n\tonBeforeMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view.\n\t */\n\tonMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data into the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalToView();\n\t\tthis.onMarshalToView();\n\t\tthis.onAfterMarshalToView();\n\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalToViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view.\n\t */\n\tonAfterMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/** @return {boolean} - True if the object is a PictView. */\n\tget isPictView()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictView;\n\n},{\"fable-serviceproviderbase\":1}]},{},[2])(2)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\t// If this is set to true, when the App initializes this will.\n\t\t// After the App initializes, initialize will be called as soon as it's added.\n\t\tAutoInitialize: true,\n\t\tAutoInitializeOrdinal: 0,\n\n\t\t// If this is set to true, when the App autorenders (on load) this will.\n\t\t// After the App initializes, render will be called as soon as it's added.\n\t\tAutoRender: true,\n\t\tAutoRenderOrdinal: 0,\n\n\t\tAutoSolveWithApp: true,\n\t\tAutoSolveOrdinal: 0,\n\n\t\tCSSHash: false,\n\t\tCSS: false,\n\t\tCSSProvider: false,\n\t\tCSSPriority: 500,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\n/** @typedef {(error?: Error) => void} ErrorCallback */\n/** @typedef {number | boolean} PictTimestamp */\n\n/**\n * @typedef {Object} Renderable\n *\n * @property {string} RenderableHash - A unique hash for the renderable.\n * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.\n * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.\n * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.\n * @property {string} [RenderMethod] - The method to use when rendering the renderable ('replace', 'append', 'prepend', 'append_once').\n */\n\n/**\n * Represents a view in the Pict ecosystem.\n */\nclass PictView extends libFableServiceBase\n{\n\t/**\n\t * @param {any} pFable - The Fable object that this service is attached to.\n\t * @param {any} [pOptions] - (optional) The options for this service.\n\t * @param {string} [pServiceHash] - (optional) The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\t//FIXME: add types to fable and ancillaries\n\t\t/** @type {any} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {String} */\n\t\tthis.UUID;\n\t\t/** @type {String} */\n\t\tthis.Hash;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t// Convenience and consistency naming\n\t\t/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.pict.AppData;\n\n\t\t/** @type {PictTimestamp} */\n\t\tthis.initializeTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastSolvedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastRenderedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalFromViewTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalToViewTimestamp = false;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!('Hash' in tmpTemplate) || !('Template' in tmpTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!('Postfix' in tmpDefaultTemplate) || !('Template' in tmpDefaultTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load the CSS if it's available\n\t\tif (this.options.CSS)\n\t\t{\n\t\t\tlet tmpCSSHash = this.options.CSSHash ? this.options.CSSHash : `View-${this.options.ViewIdentifier}`;\n\t\t\tlet tmpCSSProvider = this.options.CSSProvider ? this.options.CSSProvider : tmpCSSHash;\n\t\t\tthis.pict.CSSMap.addCSS(tmpCSSHash, this.options.CSS, tmpCSSProvider, this.options.CSSPriority);\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\t/** @type {Object<String, Renderable>} */\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\t/** @type {Renderable} */\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\t\t\tthis.addRenderable(tmpRenderable);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a renderable to the view.\n\t *\n\t * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.\n\t * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.\n\t * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.\n\t * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.\n\t * @param {string} [pRenderMethod] - (optional) The method to use when rendering the renderable (ex. 'replace').\n\t */\n\taddRenderable(pRenderableHash, pTemplateHash, pDefaultTemplateRecordAddress, pDefaultDestinationAddress, pRenderMethod)\n\t{\n\t\t/** @type {Renderable} */\n\t\tlet tmpRenderable;\n\n\t\tif (typeof(pRenderableHash) == 'object')\n\t\t{\n\t\t\t// The developer passed in the renderable as an object.\n\t\t\t// Use theirs instead!\n\t\t\ttmpRenderable = pRenderableHash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpRenderMethod = (typeof(pRenderMethod) !== 'string') ? pRenderMethod : 'replace';\n\t\t\ttmpRenderable = (\n\t\t\t\t{\n\t\t\t\t\tRenderableHash: pRenderableHash,\n\t\t\t\t\tTemplateHash: pTemplateHash,\n\t\t\t\t\tDefaultTemplateRecordAddress: pDefaultTemplateRecordAddress,\n\t\t\t\t\tContentDestinationAddress: pDefaultDestinationAddress,\n\t\t\t\t\tRenderMethod: tmpRenderMethod\n\t\t\t\t});\n\t\t}\n\n\t\tif ((typeof(tmpRenderable.RenderableHash) != 'string') || (typeof(tmpRenderable.TemplateHash) != 'string'))\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`, tmpRenderable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${tmpRenderable.RenderableHash}] pointed to template ${tmpRenderable.TemplateHash}.`);\n\t\t\t}\n\n\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                        Code Section: Initialization                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized.\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized.\n\t */\n\tonInitialize()\n\t{\n\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view initialization.\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\tthis.onAfterInitialize();\n\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Performs view initialization (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallback();\n\t\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Render                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that will be rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {any} [pRecord] - The record (data) that will be used to render the renderable.\n\t */\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pRecord)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Builds the render options for a renderable.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbuildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = {Valid: true};\n\t\ttmpRenderOptions.RenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t\t\t\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ?\n\t\t\t\t\t\t\t\tthis.options.DefaultRenderable : false;\n\t\tif (!tmpRenderOptions.RenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.Renderable = this.renderables[tmpRenderOptions.RenderableHash];\n\t\tif (!tmpRenderOptions.Renderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.DestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderOptions.Renderable.ContentDestinationAddress) === 'string') ? tmpRenderOptions.Renderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\t\tif (!tmpRenderOptions.DestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address (param ${pRenderDestinationAddress}).`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = 'Passed in as object';\n\t\t\ttmpRenderOptions.Record = pTemplateRecordAddress;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderOptions.Renderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderOptions.Renderable.DefaultTemplateRecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\t\t\ttmpRenderOptions.Record = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\treturn tmpRenderOptions;\n\t}\n\n\t/**\n\t * Assigns the content to the destination address.\n\t * \n\t * For DRY purposes on the three flavors of render.\n\t * \n\t * @param {Renderable} pRenderable - The renderable to render.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {string} pContent - The content to render.\n\t * @returns {boolean} - Returns true if the content was assigned successfully.\n\t * @memberof PictView\n\t */\n\tassignRenderContent(pRenderable, pRenderDestinationAddress, pContent)\n\t{\n\t\t// Assign the content to the destination address\n\t\tswitch(pRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'prepend':\n\t\t\t\treturn this.pict.ContentAssignment.prependContent(pRenderDestinationAddress, pContent);\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${pRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn this.pict.ContentAssignment.appendContent(pRenderDestinationAddress, pContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\treturn this.pict.ContentAssignment.assignContent(pRenderDestinationAddress, pContent);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string} [pRenderable] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t */\n\trender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] render:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${tmpRenderableHash}] to Destination [${tmpRenderDestinationAddress}]...`);\n\t\t}\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord, null, [this])\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${tmpContent.length} to Destination [${tmpRenderDestinationAddress}] using render method [${tmpRenderable.RenderMethod}].`);\n\t\t}\n\n\t\t// Assign the content to the destination address\n\t\tswitch(tmpRenderable.RenderMethod)\n\t\t{\n\t\t\tcase 'append':\n\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'prepend':\n\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t\tcase 'append_once':\n\t\t\t\t// Try to find the content in the destination address\n\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t{\n\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'replace':\n\t\t\t\t// TODO: Should this be the default?\n\t\t\tdefault:\n\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, tmpContent);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent)\n\n\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string | ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string | ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string | ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t */\n\trenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address.`);\n\t\t\treturn tmpCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] renderAsync:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.newAnticipate();\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnBeforeRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\t\t\t\tthis.onBeforeRenderAsync(fOnBeforeRenderCallback);\n\t\t\t});\n\n\t\tlet tmpContent;\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fAsyncTemplateCallback) =>\n\t\t\t{\n\t\t\t\t// Render the template (asynchronously)\n\t\t\t\tthis.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord,\n\t\t\t\t\t(pError, pContent) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderableHash}) because it did not parse the template.`, pError);\n\t\t\t\t\t\t\treturn fAsyncTemplateCallback(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpContent = pContent;\n\n\t\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${pContent.length} to Destination [${tmpRenderDestinationAddress}] using Async render method ${tmpRenderable.RenderMethod}.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Assign the content to the destination address\n\t\t\t\t\t\tswitch(tmpRenderable.RenderMethod)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'append':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prepend':\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.prependContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'append_once':\n\t\t\t\t\t\t\t\t// Try to find the content in the destination address\n\t\t\t\t\t\t\t\tlet tmpExistingContent = this.pict.ContentAssignment.getElement(`#${tmpRenderable.DestinationAddress}`);\n\t\t\t\t\t\t\t\tif (tmpExistingContent.length < 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.appendContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 'replace':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthis.pict.ContentAssignment.assignContent(tmpRenderDestinationAddress, pContent);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute the developer-overridable asynchronous post-render behavior\n\t\t\t\t\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\t\treturn fAsyncTemplateCallback();\n\t\t\t\t\t}, [this]);\n\t\t\t});\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnAfterRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\t\t\t\tthis.onAfterRenderAsync(fOnAfterRenderCallback);\n\t\t\t});\n\n\t\ttmpAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * Renders the default renderable.\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\trenderDefaultAsync(fCallback)\n\t{\n\t\t// Render the default renderable\n\t\tthis.renderAsync(fCallback);\n\t}\n\n\tbasicRender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record, null, [this]));\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbasicRenderAsync(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderable) === 'function') ? pRenderable :\n\t\t\t\t\t\t\tfalse;\n\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record,\n\t\t\t\t(pError, pContent) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderOptions.RenderableHash} because it did not parse the template.`, pError);\n\t\t\t\t\t\treturn tmpCallback(pError);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, pContent);\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t}, [this])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`;\n\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\treturn tmpCallback(tmpErrorMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered.\n\t *\n\t * @param {any} [pRenderable] - The renderable that was rendered.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable was rendered.\n\t * @param {any} [pRecord] - The record (data) that was used by the renderable.\n\t * @param {string} [pContent] - The content that was rendered.\n\t */\n\tonAfterRender(pRenderable, pRenderDestinationAddress, pRecord, pContent)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Solver                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is solved.\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved.\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks.\n\t *\n\t * @return {boolean} - True if the view was solved successfully, false otherwise.\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved.\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal From View                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tonBeforeMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view.\n\t */\n\tonMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalFromViewAsync(fCallback)\n\t{\n\n\t\tthis.onMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalFromView();\n\t\tthis.onMarshalFromView();\n\t\tthis.onAfterMarshalFromView();\n\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalFromViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view.\n\t */\n\tonAfterMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal To View                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view.\n\t */\n\tonBeforeMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view.\n\t */\n\tonMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data into the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalToView();\n\t\tthis.onMarshalToView();\n\t\tthis.onAfterMarshalToView();\n\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalToViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view.\n\t */\n\tonAfterMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/** @return {boolean} - True if the object is a PictView. */\n\tget isPictView()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictView;\n"]}